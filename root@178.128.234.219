--
-- PostgreSQL database dump
--

-- Dumped from database version 10.6 (Ubuntu 10.6-0ubuntu0.18.10.1)
-- Dumped by pg_dump version 10.6 (Ubuntu 10.6-0ubuntu0.18.10.1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: 
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: ar_internal_metadata; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ar_internal_metadata (
    key character varying NOT NULL,
    value character varying,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


ALTER TABLE public.ar_internal_metadata OWNER TO postgres;

--
-- Name: posts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.posts (
    id bigint NOT NULL,
    title character varying,
    content text,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


ALTER TABLE public.posts OWNER TO postgres;

--
-- Name: posts_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.posts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.posts_id_seq OWNER TO postgres;

--
-- Name: posts_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.posts_id_seq OWNED BY public.posts.id;


--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schema_migrations (
    version character varying NOT NULL
);


ALTER TABLE public.schema_migrations OWNER TO postgres;

--
-- Name: taggings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.taggings (
    id bigint NOT NULL,
    tag_id bigint,
    post_id bigint,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


ALTER TABLE public.taggings OWNER TO postgres;

--
-- Name: taggings_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.taggings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taggings_id_seq OWNER TO postgres;

--
-- Name: taggings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.taggings_id_seq OWNED BY public.taggings.id;


--
-- Name: tags; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tags (
    id bigint NOT NULL,
    name character varying,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
);


ALTER TABLE public.tags OWNER TO postgres;

--
-- Name: tags_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tags_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tags_id_seq OWNER TO postgres;

--
-- Name: tags_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.tags_id_seq OWNED BY public.tags.id;


--
-- Name: posts id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.posts ALTER COLUMN id SET DEFAULT nextval('public.posts_id_seq'::regclass);


--
-- Name: taggings id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.taggings ALTER COLUMN id SET DEFAULT nextval('public.taggings_id_seq'::regclass);


--
-- Name: tags id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tags ALTER COLUMN id SET DEFAULT nextval('public.tags_id_seq'::regclass);


--
-- Data for Name: ar_internal_metadata; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.ar_internal_metadata (key, value, created_at, updated_at) FROM stdin;
environment	production	2018-12-04 17:23:08.631851	2018-12-04 17:23:08.631851
\.


--
-- Data for Name: posts; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.posts (id, title, content, created_at, updated_at) FROM stdin;
2	Sinatra: Deploy a simple website on Heroku	This is a simple guide with one intention: help get something online that a person can play with and improve. Feel free to email me with any questions, I will update this as needed!\r\n\r\n### Phase 1: Getting Something Online\r\n\r\n[Sign up for Heroku](http://www.heroku.com)\r\n\r\n[Install command line heroku](https://devcenter.heroku.com/articles/heroku-cli)\r\n\r\nInstall bundler\r\n\r\n```bash\r\ngem install bundler\r\n```\r\n\r\n[Create new repo on Github with readme](https://help.github.com/articles/create-a-repo/)\r\n\r\nClone down to computer\r\n\r\n```bash\r\ngit clone .....\r\ncd directoryname\r\n```\r\n\r\nAdd Gemfile\r\n\r\n```bash\r\nbundle init\r\n```\r\n\r\nAdd Sinatra gem to Gemfile\r\n\r\n```ruby\r\n# Gemfile\r\nsource 'https://rubygems.org'\r\ngem 'sinatra'\r\n```\r\n\r\nInstall gems\r\n\r\n```bash\r\nbundle install\r\n```\r\n\r\nCreate hello.rb\r\n\r\n```ruby\r\n# hello.rb\r\nrequire 'sinatra'\r\n\r\nget '/' do\r\n  "Hello World!"\r\nend\r\n```\r\n\r\nTest run it and open in browser with localhost and port number described\r\n\r\n```bash\r\nruby hello.rb\r\n```\r\n\r\nAdd config.ru for Heroku\r\n\r\n```ruby\r\n# config.ru\r\n\r\nrequire './hello'\r\nrun Sinatra::Application\r\n```\r\n\r\nPush to Github\r\n\r\n```bash\r\ngit add .\r\ngit commit -m 'first working version'\r\ngit push origin master\r\n```\r\n\r\nCreate Heroku server (will need to log in the first time)\r\n\r\n```bash\r\nheroku create newappname\r\n```\r\n\r\nPush to Heroku server\r\n\r\n```bash\r\ngit push heroku\r\n```\r\n\r\n\r\n### Phase 2: HTML\r\n\r\nCreate a views folder for html\r\n\r\n```bash\r\nmkdir views\r\n```\r\n\r\nCreate views/index.erb\r\n\r\n```erb\r\n// views/index.erb\r\n\r\n<html>\r\n  <body>\r\n    <h1>\r\n      Index\r\n    </h1>\r\n    <p>\r\n      Holy cow I'm a webpage!\r\n    </p>\r\n  </body>\r\n</html>\r\n```\r\n\r\nCreate views/contact.erb\r\n\r\n```erb\r\n// views/contact.erb\r\n\r\n<html>\r\n  <body>\r\n    <h1>\r\n      Contact\r\n    </h1>\r\n    <p>\r\n      Leave me alone!\r\n    </p>\r\n  </body>\r\n</html>\r\n```\r\n\r\nCreate route to index and contact in hello.rb\r\n\r\n```ruby\r\n# hello.rb\r\n\r\nrequire 'sinatra'\r\n\r\nget '/' do\r\n  erb :index\r\nend\r\nget '/contact' do\r\n  erb :contact\r\nend\r\n```\r\n\r\nRestart server, push to GitHub and Heroku\r\n\r\n```bash\r\nruby hello.rb\r\ngit add .\r\ngit commit -m 'We have pages now'\r\ngit push origin master\r\ngit push heroku\r\n```\r\n\r\n### Phase 3: CSS\r\n\r\nCreate public/style.css\r\n\r\n```css\r\n/* public/style.css */\r\nh1 {\r\n  color: green;\r\n}\r\n```\r\n\r\nAdd to erb files:\r\n\r\n```erb\r\n<link href="style.css" rel="stylesheet">\r\n```\r\n\r\nMake sure it works!\r\n\r\n\r\n### Phase 4: Add template\r\n\r\nAdd template file views/layout.erb\r\n\r\n```erb\r\n// views/layout.erb\r\n\r\n<html>\r\n  <body>\r\n    <h1>\r\n      I’m the Template Title!\r\n    </h1>\r\n      <%= yield %>\r\n  </body>\r\n</html>\r\n```\r\n\r\nSpecify layout for each page in hello.rb\r\n\r\n```ruby\r\n# hello.rb\r\nrequire 'sinatra'\r\n\r\nget '/' do\r\n  erb :index, layout: :layout\r\nend\r\nget '/contact' do\r\n  erb :contact, layout: :layout\r\nend\r\n```\r\n\r\nChange each page\r\n\r\n```erb\r\n<p>\r\n  Holy cow I'm a webpage!\r\n</p>\r\n```\r\n\r\n```erb\r\n<p>\r\n  Leave me alone!\r\n</p>\r\n```\r\n\r\n### Phase 5: Add Variables\r\n\r\nAdd variable in hello.rb\r\n\r\n```ruby\r\n# hello.rb\r\n\r\nrequire 'sinatra'\r\n\r\nget '/' do\r\n@title = ‘INDEX’\r\n  erb :index, layout: :layout\r\nend\r\n\r\nget '/contact' do\r\n@title = ‘CONTACT’\r\n  erb :contact, layout: :layout\r\nend\r\n```\r\n\r\nAdd in template\r\n\r\n```erb\r\n<html>\r\n  <body>\r\n    <h1>\r\n      <%= @title %>\r\n    </h1>\r\n      <%= yield %>\r\n  </body>\r\n</html>\r\n```\r\n\r\n\r\n### Phase 6: Add server reloader\r\n\r\nInstall shotgun\r\n\r\n```bash\r\ngem install shotgun\r\n```\r\n\r\nRestart server with shotgun\r\n\r\n```bash\r\nshotgun hello.rb\r\n```\r\n\r\n### Phase 7: Would you like to know more?\r\n\r\n[Check out Jump Start Sinatra](https://www.sitepoint.com/premium/books/jump-start-sinatra)	2018-12-08 21:47:45.230951	2018-12-11 00:27:09.99635
1	Markdown and Code Blocks with Redcarpet and Rouge	My first thought when I was creating this website was:\r\n\r\n“How do I make my code blocks look nice if I don’t have a built-in content management system?”\r\n\r\nJekyll handles this nicely with Kramdown, but for Rails the solution needs 2 gems and a little bit of code.\r\n\r\n### Initial code\r\n\r\nFirst add the redcarpet and rouge gems to your gemfile\r\n\r\n```ruby\r\n# Gemfile\r\n\r\ngem 'redcarpet'\r\ngem 'rouge'\r\n```\r\n\r\nThen install your gems\r\n\r\n```bash\r\n# bash\r\nbundle install\r\n```\r\n\r\nYou can then add your code to your application helper. This is just pulling in the Redcarpet gem for markdown, adding rouge for code blocks, and setting the extensions.\r\n\r\n```ruby\r\n# application_helper.rb\r\n\r\nmodule ApplicationHelper\r\n require 'redcarpet'\r\n require 'rouge'\r\n require 'rouge/plugins/redcarpet'\r\n\r\n class MarkdownRender < Redcarpet::Render::HTML\r\n   def initialize(extensions = {})\r\n     super extensions.merge(link_attributes: { target: '_blank' })\r\n   end\r\n   include Rouge::Plugins::Redcarpet\r\n end\r\nend\r\n```\r\n\r\n### Sass\r\n\r\nThe code blocks use CSS for highlighting, so add the following to your sass file to make things pretty\r\n\r\n```css\r\n// application.scss\r\n\r\n.highlight {\r\n\r\n border-radius: 5px;\r\n font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen-Sans, Ubuntu, Cantarell, Helvetica Neue, sans-serif;\r\n font-weight: normal;\r\n font-size: 15px;\r\n padding: 10px;\r\n padding-bottom: 0px;\r\n margin-bottom: 20px;\r\n\r\n pre {\r\n   padding-bottom: 10px;\r\n }\r\n\r\n code,\r\n pre {\r\n   color: #fdce93;\r\n   background-color: #3f3f3f;\r\n }\r\n\r\n .hll {\r\n   background-color: #222;\r\n }\r\n\r\n .err {\r\n   color: #e37170;\r\n   background-color: #3d3535;\r\n }\r\n\r\n .k {\r\n   color: #f0dfaf;\r\n }\r\n\r\n .p {\r\n   color: #41706f;\r\n }\r\n\r\n .cs {\r\n   color: #cd0000;\r\n   font-weight: 700;\r\n }\r\n\r\n .gd {\r\n   color: #cd0000;\r\n }\r\n\r\n .ge {\r\n   color: #ccc;\r\n   font-style: italic;\r\n }\r\n\r\n .gr {\r\n   color: red;\r\n }\r\n\r\n .go {\r\n   color: gray;\r\n }\r\n\r\n .gs {\r\n   color: #ccc;\r\n   font-weight: 700;\r\n }\r\n\r\n .gu {\r\n   color: purple;\r\n   font-weight: 700;\r\n }\r\n\r\n .gt {\r\n   color: #0040D0;\r\n }\r\n\r\n .kc {\r\n   color: #dca3a3;\r\n }\r\n\r\n .kd {\r\n   color: #ffff86;\r\n }\r\n\r\n .kn {\r\n   color: #dfaf8f;\r\n   font-weight: 700;\r\n }\r\n\r\n .kp {\r\n   color: #cdcf99;\r\n }\r\n\r\n .kr {\r\n   color: #cdcd00;\r\n }\r\n\r\n .ni {\r\n   color: #c28182;\r\n }\r\n\r\n .ne {\r\n   color: #c3bf9f;\r\n   font-weight: 700;\r\n }\r\n\r\n .nn {\r\n   color: #8fbede;\r\n }\r\n\r\n .vi {\r\n   color: #ffffc7;\r\n }\r\n\r\n .c,\r\n .preview-zenburn .highlight .g,\r\n .preview-zenburn .highlight .cm,\r\n .preview-zenburn .highlight .cp,\r\n .preview-zenburn .highlight .c1 {\r\n   color: #7f9f7f;\r\n }\r\n\r\n .l,\r\n .preview-zenburn .highlight .x,\r\n .preview-zenburn .highlight .no,\r\n .preview-zenburn .highlight .nd,\r\n .preview-zenburn .highlight .nl,\r\n .preview-zenburn .highlight .nx,\r\n .preview-zenburn .highlight .py,\r\n .preview-zenburn .highlight .w {\r\n   color: #ccc;\r\n }\r\n\r\n .n,\r\n .preview-zenburn .highlight .nv,\r\n .preview-zenburn .highlight .vg {\r\n   color: #dcdccc;\r\n }\r\n\r\n .o,\r\n .preview-zenburn .highlight .ow {\r\n   color: #f0efd0;\r\n }\r\n\r\n .gh,\r\n .preview-zenburn .highlight .gp {\r\n   color: #dcdccc;\r\n   font-weight: 700;\r\n }\r\n\r\n .gi,\r\n .preview-zenburn .highlight .kt {\r\n   color: #00cd00;\r\n }\r\n\r\n .ld,\r\n .preview-zenburn .highlight .s,\r\n .preview-zenburn .highlight .sb,\r\n .preview-zenburn .highlight .sc,\r\n .preview-zenburn .highlight .sd,\r\n .preview-zenburn .highlight .s2,\r\n .preview-zenburn .highlight .se,\r\n .preview-zenburn .highlight .sh,\r\n .preview-zenburn .highlight .si,\r\n .preview-zenburn .highlight .sx,\r\n .preview-zenburn .highlight .sr,\r\n .preview-zenburn .highlight .s1,\r\n .preview-zenburn .highlight .ss {\r\n   color: #cc9393;\r\n }\r\n\r\n .m,\r\n .preview-zenburn .highlight .mf,\r\n .preview-zenburn .highlight .mh,\r\n .preview-zenburn .highlight .mi,\r\n .preview-zenburn .highlight .mo,\r\n .preview-zenburn .highlight .il {\r\n   color: #8cd0d3;\r\n }\r\n\r\n .na,\r\n .preview-zenburn .highlight .nt {\r\n   color: #9ac39f;\r\n }\r\n\r\n .nb,\r\n .preview-zenburn .highlight .nc,\r\n .preview-zenburn .highlight .nf,\r\n .preview-zenburn .highlight .bp,\r\n .preview-zenburn .highlight .vc {\r\n   color: #efef8f;\r\n }\r\n}\r\n\r\n```\r\n\r\n### Markdown text\r\n\r\nI use “Posts” for modelling my blog posts in Rails.\r\n\r\n```bash\r\nrails generate scaffold Posts\r\n```\r\n\r\nTherefore I will use my posts helper for the markdown_text function, which references code in the application helper. This function takes a string full of markdown and spits out HTML.\r\n\r\n```ruby\r\n# posts_helper.rb\r\n\r\ninclude ApplicationHelper\r\n\r\nmodule PostsHelper\r\n def markdown_text(text)\r\n   Redcarpet::Markdown.new(MarkdownRender, fenced_code_blocks: true).render(text).html_safe\r\n end\r\nend\r\n```\r\n\r\nI can now call that function in any erb file referenced by the posts_controller\r\n\r\n```ruby\r\n# _post.html.erb\r\n\r\n<%= markdown_text(@post.content) %>\r\n```\r\n\r\nor\r\n\r\n```ruby\r\n# some_file.html.erb\r\n\r\n<%= markdown_text(“##Anything I want!”) %>\r\n```\r\n\r\n### Markdown files\r\n\r\nNow something else I wanted to do was create static markdown pages (not just dynamic blog posts).\r\n\r\nI generated a controller (with one page in this example)\r\n\r\n```bash\r\nrails generate controller Static index\r\n```\r\n\r\nAnd I created a markdown file in /app/assets/markdowns/\r\n\r\n```markdown\r\nexample.md\r\n\r\n# Title\r\n\r\nWow look at this page!\r\n\r\n[Here is a link to Google!](https://www.google.com)\r\n```\r\n\r\nI add my markdown_file function to the static helper. Note how I reference the /app/assets/markdowns/\r\n\r\n```ruby\r\n# static_helper.rb\r\n\r\ninclude ApplicationHelper\r\n\r\nmodule StaticHelper\r\n def markdown_file(filename)\r\n   path = Rails.root.join('app', 'assets', 'markdowns', filename)\r\n   text = File.read(path)\r\n   Redcarpet::Markdown.new(MarkdownRender, fenced_code_blocks: true).render(text).html_safe\r\n end\r\nend\r\n```\r\n\r\nAnd then I can reference the file in my index\r\n\r\n```ruby\r\n# index.html.erb\r\n\r\n<%=  markdown_file('example.md') %>\r\n```\r\n\r\nAnd it is done!\r\n	2018-12-07 17:05:08.917479	2018-12-15 19:07:17.667802
5	Make a contact form with Mailgun	Making a contact form can be surprisingly difficult, a number of pieces have to work together to make the magic happen and that is what this post is all about! For this article I am using:\r\n\r\n- Ruby on Rails 5 (The excellent web framework)\r\n- Mailgun (The email service)\r\n- Namecheap (DNS)\r\n- Heroku (Web hosting)\r\n\r\nLet's get started!\r\n\r\n### Sign up for Mailgun\r\n\r\nMake yourself an account at [mailgun.com](https://www.mailgun.com/).\r\n\r\nSpecify that you want to use a mg subdomain, so that you will end up using mg.yourdomain.com for Mailgun.\r\n\r\n### Add DNS Settings\r\n\r\nMailgun will not work until they read the proper DNS settings from your provider. For most providers the Mailgun-provided settings will be sufficient, but Namecheap was a whole different ball of wax (lucky me!). I have Namecheap's "Private Email Service" and have included those settings as well.\r\n\r\nPrivate email:\r\n\r\n| Hostname | Record Type | Priority | Value                                    |\r\n|----------|-------------|----------|------------------------------------------|\r\n| @        | MX          | 10       | mx1.privateemail.com                     |\r\n| @        | MX          | 10       | mx2.privateemail.com                     |\r\n| @        | TXT         |          | v=spf1 include:spf.privateemail.com ~all |\r\n\r\nMailgun host records:\r\n\r\n| Hostname         | Record Type | Value                 |\r\n|------------------|-------------|-----------------------|\r\n| email.mg         | CNAME       | mailgun.org.          |\r\n| mx._domainkey.mg | TXT         | k=rsa; p=MIGfM... etc |\r\n\r\nMailgun mail settings:\r\n\r\n| Hostname | Record Type | Priority | Value            |\r\n|----------|-------------|----------|------------------|\r\n| mg       | MX          | 10       | mxa.mailgun.org. |\r\n| mg       | MX          | 10       | mxa.mailgun.org. |\r\n\r\n### You don't need the Mailgun Heroku addon\r\n\r\nThat's right, I use a config var instead.\r\n\r\n### Add config vars\r\n\r\nNow add that .env file to your .gitignore. This is vital, if you don't do this then the whole world will have access to your api keys. That is bad.\r\n\r\nSet up your gitignore in the main project directory\r\n\r\n```bash\r\ntouch .gitignore\r\necho '.env' >> .gitignore\r\ngit add .\r\ngit commit -m 'add env to gitignore'\r\ngit push\r\n```\r\n\r\nand add your Mailgun config var to your .env in the  main project directory. This allows you to use config variables locally when you run 'heroku local'\r\n\r\n```bash\r\ntouch .env\r\necho 'mailgun_secret_api_key=XXXXXXXXXXXX' >> .env\r\n```\r\n\r\nAnd add the same to Heroku so you can use the config var in production\r\n\r\n```bash\r\nheroku config:set mailgun_secret_api_key=XXXXXXXXXXXX\r\n```\r\n\r\n### Add the gem\r\n\r\n```ruby\r\n# Gemfile\r\n\r\ngem 'mailgun-ruby'\r\n```\r\n\r\nand install it\r\n\r\n```bash\r\nbundle install\r\n```\r\n\r\n### Code\r\n\r\nCreate the model\r\n\r\n```bash\r\nrails generate model Messages --skip-migration\r\n```\r\n\r\nUse this code for the model:\r\n\r\n```ruby\r\n# message.rb\r\n\r\nrequire 'mailgun-ruby'\r\n\r\nclass Message\r\n  include ActiveModel::Model\r\n  attr_accessor :name, :email, :phone_number, :body\r\n  validates :name, :email, :phone_number, :body, presence: true\r\n\r\n  def send\r\n    mg_client = Mailgun::Client.new ENV['mailgun_secret_api_key']\r\n    info = {\r\n      from: email,\r\n      to:   'alan@alanvardy.com',\r\n      subject: "Email from #{name} - alanvardy.com",\r\n      text:    "From: #{name}, Email: #{email}, Phone: #{phone_number} \\n\\n #{body}"\r\n                  }\r\n    mg_client.send_message 'mg.alanvardy.com', info\r\n  end\r\nend\r\n```\r\n\r\nCreate the controller\r\n\r\n```bash\r\nrails generate controller Messages new create\r\n```\r\n\r\nUse this code for the controller:\r\n\r\n```ruby\r\n# messages_controller.rb\r\n\r\nclass MessagesController < ApplicationController\r\n  def new\r\n    @message = Message.new\r\n  end\r\ndef create\r\n    @message = Message.new message_params\r\nif @message.valid?\r\n      @message.send\r\n      redirect_to root_path\r\n      flash[:success] = "I have received your message and will be in touch soon!"\r\n    else\r\n      flash[:warning] = "There was an error sending your message. Please try again."\r\n      render :new\r\n    end\r\n  end\r\nprivate\r\ndef message_params\r\n    params.require(:message).permit(:name, :email, :phone_number, :body)\r\n  end\r\nend\r\n```\r\n\r\nand finally the code for new.html.erb\r\n\r\n```erb\r\n<%= form_for @message, url: messages_create_path do |f| %>\r\n            <div class="form-group">\r\n            <%= f.label :name %>\r\n            <%= f.text_field :name, class: 'form-control'%>\r\n            </div>\r\n\r\n            <div class="form-group">\r\n            <%= f.label :email %>\r\n            <%= f.email_field :email, class: 'form-control'%>\r\n            </div>\r\n\r\n            <div class="form-group">\r\n            <%= f.label :phone_number %>\r\n            <%= f.telephone_field :phone_number, class: 'form-control'%>\r\n            </div>\r\n\r\n            <div class="form-group">\r\n            <%= f.label :body %>\r\n            <%= f.text_area :body, class: 'form-control', rows: '5'%>\r\n            </div>\r\n\r\n            <div class="form-group">\r\n            <%= f.submit 'Send Form', class: 'btn btn-outline-primary'%>\r\n            </div>\r\n        <% end %>\r\n```\r\n\r\nStart up your local server\r\n\r\n```bash\r\nheroku local\r\n```\r\n\r\nAnd let me know if you have any issues!	2018-12-11 23:08:25.231904	2018-12-15 19:06:39.813835
4	Add automated testing with Guard	The guardfile is sourced from [Michael Hartl’s Ruby on Rails Tutorial](https://www.railstutorial.org/book), which is widely considered to be the best tutorial on Rails.\r\n\r\nFollowing these steps will enable you to use some basic automated testing at the command line. Whenever you change one of the files specified in the Guardfile, Guard will automatically re-run the tests.\r\n\r\nI use Terminator for my terminal, as it splits into smaller “sub terminals”. One will be for running a local server, another for automated testing, and a third for everything else like git commands and installing gems.\r\n\r\n### The Steps\r\n\r\nAdd Guard to gemfile\r\n\r\n```ruby\r\n# Gemfile\r\n\r\ngroup :test do\r\n# other test gems\r\n gem 'guard'\r\n gem 'guard-minitest'\r\nend\r\n```\r\n\r\nInstall gems\r\n\r\n```bash\r\nbundle install\r\n```\r\n\r\nInitialize Guard\r\n\r\n```bash\r\nbundle exec guard init\r\n```\r\n\r\nand paste the following code into your Guardfile\r\n\r\n```ruby\r\n# Guardfile\r\n\r\n# Defines the matching rules for Guard.\r\n\r\nguard :minitest, spring: true, all_on_start: false do\r\n watch(%r{^test/(.*)/?(.*)_test\\.rb$})\r\n watch('test/test_helper.rb') { 'test' }\r\n watch('config/routes.rb')    { integration_tests }\r\n watch(%r{^app/models/(.*?)\\.rb$}) do |matches|\r\n   "test/models/#{matches[1]}_test.rb"\r\n end\r\n watch(%r{^app/controllers/(.*?)_controller\\.rb$}) do |matches|\r\n   resource_tests(matches[1])\r\n end\r\n watch(%r{^app/views/([^/]*?)/.*\\.html\\.erb$}) do |matches|\r\n   ["test/controllers/#{matches[1]}_controller_test.rb"] +\r\n     integration_tests(matches[1])\r\n end\r\n watch(%r{^app/helpers/(.*?)_helper\\.rb$}) do |matches|\r\n   integration_tests(matches[1])\r\n end\r\n watch('app/views/layouts/application.html.erb') do\r\n   'test/integration/site_layout_test.rb'\r\n end\r\n watch('app/helpers/sessions_helper.rb') do\r\n   integration_tests << 'test/helpers/sessions_helper_test.rb'\r\n end\r\n watch('app/controllers/sessions_controller.rb') do\r\n   ['test/controllers/sessions_controller_test.rb',\r\n    'test/integration/users_login_test.rb']\r\n end\r\n watch('app/controllers/account_activations_controller.rb') do\r\n   'test/integration/users_signup_test.rb'\r\n end\r\n watch(%r{app/views/users/*}) do\r\n   resource_tests('users') +\r\n     ['test/integration/microposts_interface_test.rb']\r\n end\r\nend\r\n\r\n# Returns the integration tests corresponding to the given resource.\r\n\r\ndef integration_tests(resource = :all)\r\n if resource == :all\r\n   Dir['test/integration/*']\r\n else\r\n   Dir["test/integration/#{resource}_*.rb"]\r\n end\r\nend\r\n\r\n# Returns the controller tests corresponding to the given resource.\r\n\r\ndef controller_test(resource)\r\n "test/controllers/#{resource}_controller_test.rb"\r\nend\r\n\r\n# Returns all tests for the given resource.\r\ndef resource_tests(resource)\r\n integration_tests(resource) << controller_test(resource)\r\nend\r\n```\r\n\r\nNow you can start the automated tests by running\r\n\r\n```bash\r\nbundle exec guard\r\n```\r\n\r\nI recommend adding an alias to your terminal shell of choice.\r\n	2018-12-10 17:28:38.234928	2018-12-15 19:06:50.27876
3	Back up your Heroku databases with a shell script	If your Heroku app isn’t professional tier, backups get a little more labour intensive. You will need to manually backup and download your databases and store them yourself.To help me do this, I wrote a shell script. \r\n\r\nFirst you need to create a shell script\r\n\r\n```bash\r\ntouch backupdb.sh\r\n```\r\n\r\nopen it\r\n\r\n```bash\r\ngedit backupdb.sh\r\n```\r\n\r\nPaste in the following code (Just replace the app1 app2 app3 etc. with the names of the apps you with to back up)\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\napps=(app1 app2 app3)\r\nDATE=`date +%Y-%m-%d`\r\necho $DATE\r\nmkdir -p "${DATE}"\r\nfor i in ${apps[@]}; do\r\n   heroku pg:backups:capture --app ${i}\r\n   url=$(heroku pg:backups:url --app ${i})\r\n   wget -O $DATE/${i} $url\r\ndone\r\n```\r\n\r\nMake the script executable\r\n\r\n```bash\r\nchmod +x backupdb.sh\r\n```\r\n\r\nand run it!\r\n\r\n```bash\r\n./backupdb.sh\r\n```\r\n\r\n[Check out Heroku for more indepth information](https://devcenter.heroku.com/articles/heroku-postgres-backups)\r\n\r\n	2018-12-09 16:56:25.386261	2018-12-15 19:07:05.536665
6	Deploy a Rails app with Dokku and Digital Ocean	Credit to [Dave Kiss](https://davekiss.com/create-your-own-heroku-clone-for-5-a-month-with-dokku/)\r\n\r\n### Buy a domain name\r\n\r\nI use [Namecheap](https://www.namecheap.com/) and have been happy with them, I don't know if they are the best but they are certainly not the worst and I have had no issues with them. Just stay away from GoDaddy.\r\n\r\n### Point your Domain name at Digital Ocean's DNS\r\n\r\nWe are doing this now because it can take a while for the settings to distribute across the web. In Namecheap I selected "Custom DNS" under Nameservers and put in Digital Ocean's 3 name servers:\r\n\r\n- ns1.digitalocean.com\r\n- ns2.digitalocean.com\r\n- ns3.digitalocean.com\r\n\r\nI really like how creative they were with the names.\r\n\r\n### Sign up for Digital Ocean\r\n\r\n[Sign up for Digital Ocean using this link](https://m.do.co/c/f50e5f739663) to get $100 in free credits over 60 days. Full disclosure: Once you spend $25 on their service I will get a $25 credit on my service. And I like free credits. I'd also be really happy that someone read this post. So please use the link!\r\n\r\n### Create a Droplet\r\n\r\nYou can create a droplet (read: virtual private server) with Dokku pre-installed! When creating a droplet choose Dokku under the One-Click-Apps tab, [add your SSH keys](https://timleland.com/copy-ssh-key-to-clipboard/) and boot that puppy up.\r\n\r\n### Finish Dokku Setup\r\n\r\nDo this right away, if someone else beats you to it then they will have access to your server instead of you.\r\n\r\nNavigate to your server's IP address (listed in Digital Ocean) and finish the setup on the admin page that appears. You will have to paste in your public ssh key again and I recommend using virtual host naming for your apps. It means that if you create an app called myapp, it will be accessible at myapp.mydomain.com\r\n\r\n### Configure Digital Ocean's DNS\r\n\r\nAdd the domain that you purchased on namecheap and you should see 3 entries pointing at each of Digital Ocean's cleverly named servers.\r\n\r\nNow you need to create 'A' records for your domains. I created the following:\r\n\r\n| Type | Hostname                     | Value                |\r\n|------|------------------------------|----------------------|\r\n| A    | mydomain.com                 | (select your server) |\r\n| A    | www.mydomain.com             | (select your server) |\r\n| A    | my-awesome-app.mydomain.com  | (select your server) |\r\n\r\netc.\r\n\r\n### Install dokku-cli\r\n\r\n[dokku-cli](https://github.com/SebastianSzturo/dokku-cli) is very similar to the Heroku command line tool and is a joy to use. No configuration is needed! Just run in your project directory and use 'dokku' in the place of 'heroku'.\r\n\r\nInstall Dokku CLI\r\n\r\n```bash\r\ngem install dokku-cli\r\n```\r\n\r\n### Create an app on your server\r\n\r\nSSH onto your server\r\n\r\n```bash\r\nssh root@your.droplet.ip.address\r\n```\r\n\r\nCreate an app\r\n\r\n```bash\r\ndokku apps:create my-awesome-app\r\n```\r\n\r\nInstall Postgres, create and link database\r\n\r\n```bash\r\nsudo dokku plugin:install https://github.com/dokku/dokku-postgres.git\r\ndokku postgres:create my-awesome-db\r\ndokku postgres:link my-awesome-db my-awesome-app\r\n```\r\n\r\nCreate a [swap file](https://help.ubuntu.com/community/SwapFaq) to help out on the ram front. You will only see output after the 3rd line.\r\n\r\n```bash\r\nsudo fallocate -l 2G /swapfile\r\nsudo chmod 600 /swapfile\r\nsudo mkswap /swapfile\r\nsudo swapon /swapfile\r\n```\r\n\r\nOpen fstab with Nano\r\n\r\n```bash\r\nsudo nano /etc/fstab\r\n```\r\n\r\nAdd this line at the bottom\r\n\r\n```bash\r\n/swapfile none swap sw 0 0\r\n```\r\n\r\nAnd then use CTRL+x, y, and then enter to save and exit.\r\n\r\n### Add remote repository\r\n\r\nNavigate to your my-awesome-app project directory and add the repository\r\n\r\n```bash\r\ngit remote add dokku dokku@your.droplet.ip.address:my-awesome-app\r\n```\r\n\r\nYou can now push your code with\r\n\r\n```bash\r\ngit push dokku master\r\n```\r\n\r\n### Automatic Migrations\r\n\r\nThis one just runs `rails db:migrate` automatically.\r\n\r\nCreate app.json in the root directory of your app\r\n\r\n```json\r\n{\r\n  "name": "my-awesome-app",\r\n  "description": "My awesome Rails app, running on Dokku!",\r\n  "keywords": [\r\n    "dokku",\r\n    "rails"\r\n  ],\r\n  "scripts": {\r\n    "dokku": {\r\n      "postdeploy": "bundle exec rails db:migrate"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Free SSL with Let's Encrypt\r\n\r\n[Let's Encrypt](https://letsencrypt.org/) provides free SSL certificates. You can find more complete instructions and explanations [here](https://medium.com/@pimterry/effortlessly-add-https-to-dokku-with-lets-encrypt-900696366890).\r\n\r\nSSH onto your server\r\n\r\n```bash\r\nssh root@your.droplet.ip.address\r\n```\r\n\r\nInstall Let's Encrypt\r\n\r\n```bash\r\nsudo dokku plugin:install https://github.com/dokku/dokku-letsencrypt.git\r\n```\r\n\r\nUpdate if it was already installed\r\n\r\n```bash\r\ndokku plugin:update letsencrypt\r\n```\r\n\r\nSet your email address (note that you need to change MYAPP and ME@MYEMAIL.COM)\r\n\r\n```bash\r\ndokku config:set --no-restart my-awesome-app DOKKU_LETSENCRYPT_EMAIL=ME@MYEMAIL.COM\r\n```\r\n\r\nTurn it on\r\n\r\n```bash\r\ndokku letsencrypt my-awesome-app\r\n```\r\n\r\nSet up auto-renewal with a cronjob\r\n\r\n```bash\r\ndokku letsencrypt:cron-job --add\r\n```\r\n\r\n### Add checks\r\n\r\nThis feature is rather nice, it makes Dokku check to make sure that your freshly uploaded code actually starts up before switching over to it!\r\n\r\nCreate a file called CHECKS in the root of your project directory\r\n\r\n```bash\r\n# CHECKS\r\n\r\nWAIT=10  \r\nATTEMPTS=6  \r\n/check.txt it_works\r\n```\r\n\r\nAdd the following route to config/routes.rb\r\n\r\n```ruby\r\nget '/check.txt', to: proc {[200, {}, ['it_works']]}\r\n```\r\n\r\nAnd it will make a call to that route when it starts up your new code, thereby ensuring that the new server actually started.\r\n\r\n### Backup your databases\r\n\r\nI wrote a shell script for this very issue. It downloads all your Postgres databases from Heroku and Dokku and uploads them (conveiently dated) to Google Drive. [Check it out](https://github.com/alanvardy/dbbackup) and let me know what you think!	2018-12-13 21:37:47.080369	2018-12-17 00:48:45.488482
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.schema_migrations (version) FROM stdin;
20181130161846
20181214220500
20181214220623
\.


--
-- Data for Name: taggings; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.taggings (id, tag_id, post_id, created_at, updated_at) FROM stdin;
1	10	6	2018-12-15 19:12:46.932423	2018-12-15 19:12:46.932423
2	8	6	2018-12-15 19:12:46.93746	2018-12-15 19:12:46.93746
3	9	6	2018-12-15 19:12:46.940693	2018-12-15 19:12:46.940693
4	1	6	2018-12-15 19:12:46.943932	2018-12-15 19:12:46.943932
5	6	6	2018-12-15 19:12:46.947099	2018-12-15 19:12:46.947099
6	5	5	2018-12-15 19:13:24.114928	2018-12-15 19:13:24.114928
7	8	5	2018-12-15 19:13:24.118755	2018-12-15 19:13:24.118755
8	1	5	2018-12-15 19:13:24.122025	2018-12-15 19:13:24.122025
9	6	5	2018-12-15 19:13:24.125436	2018-12-15 19:13:24.125436
10	11	4	2018-12-15 19:13:41.870611	2018-12-15 19:13:41.870611
11	1	4	2018-12-15 19:13:41.873823	2018-12-15 19:13:41.873823
12	4	4	2018-12-15 19:13:41.876715	2018-12-15 19:13:41.876715
13	12	3	2018-12-15 19:14:18.710842	2018-12-15 19:14:18.710842
14	2	3	2018-12-15 19:14:18.713387	2018-12-15 19:14:18.713387
15	1	3	2018-12-15 19:14:18.71561	2018-12-15 19:14:18.71561
16	7	3	2018-12-15 19:14:18.717857	2018-12-15 19:14:18.717857
17	13	3	2018-12-15 19:14:44.069663	2018-12-15 19:14:44.069663
18	12	2	2018-12-15 19:14:56.842418	2018-12-15 19:14:56.842418
19	3	2	2018-12-15 19:14:56.846602	2018-12-15 19:14:56.846602
20	1	1	2018-12-15 19:15:10.495123	2018-12-15 19:15:10.495123
\.


--
-- Data for Name: tags; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.tags (id, name, created_at, updated_at) FROM stdin;
1	Rails 5	2018-12-15 19:07:36.152474	2018-12-15 19:07:36.152474
2	Linux	2018-12-15 19:07:50.709231	2018-12-15 19:07:50.709231
3	Sinatra	2018-12-15 19:08:02.968762	2018-12-15 19:08:02.968762
4	Ruby	2018-12-15 19:08:13.219827	2018-12-15 19:08:13.219827
5	API	2018-12-15 19:08:37.475528	2018-12-15 19:08:37.475528
6	Servers	2018-12-15 19:09:15.8834	2018-12-15 19:09:15.8834
7	Shell Scripting	2018-12-15 19:09:27.843558	2018-12-15 19:09:27.843558
8	DNS	2018-12-15 19:09:44.458636	2018-12-15 19:09:44.458636
9	Dokku	2018-12-15 19:09:59.909479	2018-12-15 19:09:59.909479
10	Digital Ocean	2018-12-15 19:10:20.962867	2018-12-15 19:10:20.962867
11	Minitest	2018-12-15 19:10:50.475081	2018-12-15 19:10:50.475081
12	Heroku	2018-12-15 19:11:11.97608	2018-12-15 19:11:11.97608
13	Postgres	2018-12-15 19:14:31.832245	2018-12-15 19:14:31.832245
\.


--
-- Name: posts_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.posts_id_seq', 6, true);


--
-- Name: taggings_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.taggings_id_seq', 20, true);


--
-- Name: tags_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.tags_id_seq', 13, true);


--
-- Name: ar_internal_metadata ar_internal_metadata_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ar_internal_metadata
    ADD CONSTRAINT ar_internal_metadata_pkey PRIMARY KEY (key);


--
-- Name: posts posts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.posts
    ADD CONSTRAINT posts_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: taggings taggings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.taggings
    ADD CONSTRAINT taggings_pkey PRIMARY KEY (id);


--
-- Name: tags tags_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tags
    ADD CONSTRAINT tags_pkey PRIMARY KEY (id);


--
-- Name: index_taggings_on_post_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX index_taggings_on_post_id ON public.taggings USING btree (post_id);


--
-- Name: index_taggings_on_tag_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX index_taggings_on_tag_id ON public.taggings USING btree (tag_id);


--
-- Name: taggings fk_rails_2c662e858e; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.taggings
    ADD CONSTRAINT fk_rails_2c662e858e FOREIGN KEY (post_id) REFERENCES public.posts(id);


--
-- Name: taggings fk_rails_9fcd2e236b; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.taggings
    ADD CONSTRAINT fk_rails_9fcd2e236b FOREIGN KEY (tag_id) REFERENCES public.tags(id);


--
-- PostgreSQL database dump complete
--

